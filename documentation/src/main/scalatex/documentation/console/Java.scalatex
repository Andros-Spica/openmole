@import documentation.Objects._

@sect{Execute your java code into OpenMOLE}

  OpenMOLE makes it simple to include your own java code in a workflow. A java program can be encapsulated in a task of a workflow. To achieve this, a jar archive of the program should be given to a Scala Task.

  @sect{Hello world}
      Let us consider the simple code @em{Hello.java} in a directory named @i{hello} (package structure):
      @hl.highlight("""
      package hello;

      public class Hello {
        public static void run(int arg) {
          System.out.println("Hello from Java! " + arg);
        }
      }""", "java")
      @p We compile the code and generate the jar file as follows:
      @hl.highlight("""
      mkdir hello
      mv Hello.java hello
      cd hello
      javac Hello.java
      cd ..
      jar cvf Hello.jar hello""", "plain")

      @p Now, we will run the java program inside the OpenMOLE runtime with the following script (copy-paste that in the OpenMOLE console).
      @hl.openmole("""
      import org.openmole.plugin.domain.collection._
      import org.openmole.plugin.task.scala._

      val proto1 = Val[Int]

      val explo = ExplorationTask(proto1 in (0 until 10))

      //Defines the task to perform the hello function
      val javaTask = ScalaTask("Hello.run(proto1)") set (
        libraries += "/path/to/Hello.jar",
        imports += "hello.Hello",
        inputs += proto1
      )

      val ex = explo -< javaTask start""")

      @p The output should look like that (the order in which the lines are printed might be different in your case):
      @hl.highlight("""
      Hello from Java! 0
      Hello from Java! 1
      Hello from Java! 2
      Hello from Java! 3
      Hello from Java! 4
      Hello from Java! 5
      Hello from Java! 6
      Hello from Java! 7
      Hello from Java! 8
      Hello from Java! 9
      Hello from Java! 10""", "plain")

  @sect{Computing}
    @p In the general case a task is used to compute some output values depending on some input values. To illustrate that lets consider another Java code:
    @hl.highlight("""
    package hello;

    public class Hello {
      public static double[] run(double arg1, double arg2) {
        return double[]{arg1 * 10, arg2 * 10};
      }
    }""", "java")

    @p Once you have package this code in the same way as in above, it can be explored:

      @hl.openmole("""
      import org.openmole.plugin.domain.collection._
      import org.openmole.plugin.sampling.combine._
      import org.openmole.plugin.task.scala._
      improt org.openmole.plugin.hook.file._

      val arg1 = Val[Double]
      val arg2 = Val[Double]
      val out1 = Val[Double]
      val out2 = Val[Double]

      val explo = ExplorationTask(arg1 in (0 until 10) x arg2 in (0 until 10))

      val javaTask = ScalaTask("val res = Hello.run(arg1, arg2); val out1 = res[0]; val out2 = res[1]") set (
        libraries += "/path/to/Hello.jar",
        imports += "hello.Hello",
        inputs += (arg1, arg2),
        outputs += (arg1, arg2, out1, out2)
      )

      // save the result in a CSV file
      val csvHook = CSVHook("/tmp/result.csv")

      val ex = explo -< (javaTask hook csvHook) start""")

    @p This workflow explores the 2 arguments of the hello function and saves the results in a CSV file.

  @sect{Working with files}
      @p Let's consider another hello world code Hello.java which reads the content of a file and writes it to another file.
      @hl.highlight("""
      package hello;

      import java.io.*;

      public class Hello {

        public static void run(int arg, File input, File output) throws IOException {
          //Read the input file
          String content = readFileAsString(input);
          PrintStream myStream = new PrintStream(new FileOutputStream(output));
          try {
            myStream.println(content + "  " + arg);
          } finally {
            myStream.close();
          }
        }

        private static String readFileAsString(File file) throws IOException {
          byte[] buffer = new byte[(int) file.length()];
          BufferedInputStream f = null;
          try {
            f = new BufferedInputStream(new FileInputStream(filePath));
            f.read(buffer);
          } finally {
            if (f != null) try { f.close(); } catch (IOException ignored) { }
          }
          return new String(buffer);
        }
      }""", "java")

      @p Now, we will run the java program inside the OpenMOLE runtime with the following script:

      @hl.openmole("""
      import org.openmole.plugin.task.scala._
      import org.openmole.plugin.hook.file._
      import org.openmole.plugin.domain.collection._

      val proto1 = Val[Int]
      val inputFile = Val[File]
      val outputFile = Val[File]

      val explo = ExplorationTask(proto1 in (0 to 10))

      //Defines the GroovyTask as a launcher of the hello executable
      val javaTask =
        ScalaTask("val outputFile = newFile(); Hello.run(proto1, inputFile, outputFile)") set (
          libraries += "/path/to/my/Hello.jar",
          imports += "hello.Hello",
          inputs += proto1,
          outputs += proto1,
          default(inputFile) := "/path/to/my/input/file"
        )

      //Save the output file locally
      val copyHook =
        CopyFileHook(
          outputFile,
          "/path/to/save/the/output/file/out-${proto1}.txt"
        )

      val ex = explo -< (javaTask hook copyHook) start""")

      @p This tutorial works for simple Java programs. However, this approach has several limitations that can be overcome by including your code in a OpenMOLE plugin, <a href="http://www.openmole.org/?page_id=312">see this page</a>.
