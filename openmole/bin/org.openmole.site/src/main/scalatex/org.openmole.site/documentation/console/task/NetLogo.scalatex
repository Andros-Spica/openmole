@import org.openmole.site.Objects._
@import org.openmole.site.Resource._

@def variables = """
    val density = Val[Double]
    val seed = Val[Int]
    val burned = Val[Double]""".stripMargin

@def exploration = """
    val exploration =
      ExplorationTask(
        (density in (20.0 to 80.0 by 10.0)) x
        (seed in (UniformDistribution[Int]() take 10))
      )""".stripMargin

@def netlogo = """
    val cmds = List(
      "random-seed ${seed}",
      "setup",
      "while [any? turtles] [go]")

    val fireTask =
      NetLogo5Task("/path/to/the/Fire.nlogo", cmds) set (
        inputs += seed,
        netLogoInputs += (density, "density"),
        netLogoOutputs += ("burned-trees", burned)
      )""".stripMargin

@def csvHook = """
  val csvHook = AppendToCSVFileHook("result.csv", density, burned, seed)"""

@sect{Embed your NetLogo model}
  In this example, we present step by step how to explore a NetLogo model. @a("The Fire model", href := fireNLogo.file) is a
  common NetLogo example. It studies the percolation of a fire in a forest depending on the density of the forest.

  @sect{The simulation}
    We would like to study the impact of the @i{density} factor for a fixed population size. To do this, let's
   build a design of experiment where the @i{density} factor ranges from 20% to 80% by steps of 10.

  @p Since the Fire model is stochastic, we are interested in doing replications for each instance of the
  @i{density} factor. Results for each replication will be stored it in a @i{CSV} file.
  In this example case, we will perform 10 replications per step (even though it is a way too small sample to draw up
  any formal conclusion).

  @p You can get the NetLogo implementation of the model
  @a("here", href := "http://www.openmole.org/files/segregation.nlogo").

  @sect{The Design of Experiment}
    We first need to define 2 OpenMOLE variables in order to repeat our experience 10 times for every step of the
    @i{density} exploration. These 2 variables are:
    @ul
	  @li{an integer (Int) representing the seed of the random number generator for exploring the replications,}
	  @li{and a Double to set the value of @i{density},}

    @br @hl.openmole(variables)

    @p We can now define a design of experiment need the range where the @i{similar_wanted} varies from 20 to 80 by step of 10 and replication takes 10 random values:

    @br @hl.openmole(exploration, header = variables)

    @p This design of experiment will generate 70 distinct sets of input values for the NetLogo model:
    @ul
      @li{10 replications with 10 different seeds for @i{density} = 20%}
      @li{10 replications with 10 different seeds for @i{density} = 30%}
      @li{...}
      @li{10 replications with 10 different seeds for @i{density} = 80%}

    @p Now we want to compose this design of experiment in a complete workflow in order to run 70 times the model.

  @sect{The NetLogo task}
    Let's construct the main task of the workflow: the one running the NetLogo code. So let's build a NetLogoTask by providing to OpenMOLE:
    @ul
	  @li{the path of the NetLogo model, i.e. the nlogo file,}
	  @li{the list of NetLogo commands that OpenMOLE needs to run}
	@p in this example, the commands contains:
	@ul
	  @li{@i{random-seed} that initialises the random number generator of NetLogo using the seed provided by OpenMOLE,}
	  @li{@i{setup} that calls the setup function of the netlogo file to initialise the model,}
	  @li{@i{go}, a function that runs the model, for this particular model this function is called until no more turttle are active.}
	@p The function @i{go-openMOLE} takes three parameters:

	@br @hl.openmole(netlogo, header =
	s"""
	$variables
	$exploration
	""")

    @p The @i{replication} and the @i{density} OpenMOLE variables are used as parameters of the NetLogo program.
    Therefore they appear as inputs of the NetLogoTask.

    @p Similarly, 1 output of the model is considered and collected by OpenMOLE at the end of each model execution.
    It is noted as @i{netLogoOutputs} in the task definition.

  @sect{Storing the results}
    OpenMOLE usually delegates the tasks execution to many different computers. To gather the results of these remote
    executions, we use a mechanism called @i{hooks}. Hooks can be assimilated to a listener that saves or display
    results. They are more thoroughly described in a
    @a("specific section of the documentation", href := DocumentationPages.root.console.hook.file).

    @p Here we will create a hook to listen to the model executions and save the results in a CSV file at the end of
    each of the 70 runs.

    @br @hl.openmole(csvHook, header =
    s"""
	$variables
	$exploration
	$netlogo
	""")

  @sect{Bringing all the pieces together}
    Now that we have defined each component, we can compose the workflow that brings all the pieces of the simulation
    together:
    @br @hl.openmole(s"""
$variables
$exploration
$netlogo
$csvHook

    val ex = exploration -< (fireTask hook csvHook) start""")

    @p To see the progress of the simulation, print the state of the execution variable: @hl.openmole("""print(ex)""", test = false)
    @p At the end of the execution you will find the a file called @i{result.csv}, which compiles the output values.
