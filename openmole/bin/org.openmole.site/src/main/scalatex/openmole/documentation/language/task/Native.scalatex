
@import org.openmole.site._

@sect{Embed external applications (C, C++, Python, R, Scilab...)}

  In OpenMOLE, a generic task named @hl.openmole("CARETask") offers to run external applications packaged with @a("CARE", href := "http://reproducible.io/"). CARE makes it possible to package your application from any Linux computer, and then re-execute it on any other Linux computer. The CARE / OpenMOLE pair is a very efficient way to distribute your application on a very large scale with very little effort.

  @p You should first install CARE: download CARE, extract the archive and add the path to the executable to your PATH variable (export PATH=/path/to/the/care/folder:$PATH).

  @p The @hl.openmole("CARETask") has been designed to embed native binaries such as programs compiled from C, C++, Fortran, Scilab, R... Embedding an application in a @hl.openmole("CARETask") happens in 2 phases.

  @p @b{First} you should package your application so that it executes on any Linux environment. @b{Second}, you should provide the resulting package along with some other information to OpenMOLE.

  @p Let's study two concrete use cases of packaging an existing application with CARE, in order to embed it in OpenMOLE. You should be able to achieve exactly the same process with almost any executable running on Linux.

  @sect{An example with R}

    Our first example R script contained in a file @i{myscript.R}. We want to distribute the execution of this R code to the grid.

    @p First your script should run in headless mode with no input required from the user during the execution. Your script should produce files or write its results to the standard output so that OpenMOLE can bring them back from the remote execution environment.

    @p Here is an example R script matching these criteria:
    @br @hl.highlight("""
      args<-commandArgs(trailingOnly = TRUE)
      data<-read.csv("data.csv",header=T,sep=",")
      result<-as.numeric(args[1])*data
      write.csv(result,"result.csv", row.names=FALSE)""", "R")

    @p With an example @i{data.csv}:
    @br @hl.highlight("""
    h1,h2,h3
    7,8,9
    9,7,3
    1,1,1""", "plain")

    @p This reads a file called @i{data.csv}, multiply its content by a number provided in the command line and write the result an output file called @i{results.csv}. To call this script from the command line you should type: @hl.highlight("R -f script.R --slave --args 4", "plain"), considering you have @i{R} installed on your system.

    @p Once the script is up and running, remember that the first step to run it from OpenMOLE is to package it. This is done using CARE on your system.
    @br @hl.highlight("""care -r /home/reuillon/ -o r.tgz.bin R -f script.R --slave --args 4""", "plain")

    @p Notice how the command line is identical to the original one. The call to the @i{R} script remains unchanged, as CARE and its options are inserted at the beginning of the command line.

    @p A @i{care.tgz.bin} file is created. It is an archive containing a portable version of your execution. It can be extracted and executed on any other Linux platform.

    @p The method described here packages everything, including @i{R} itself! Therefore there is no need to install @i{R} on the target execution machine. All that is needed is the remote execution host runs Linux, which is the case for the vast majority of high performance computing environments.

    @p Packaging an application is done @b{once and for all} by running the original application against CARE. CARE's re-execution mechanisms allows you to change the original command line when re-running your application. This way you can update the parameters passed on the command line and the re-execution will be impacted accordingly. As long as all the configuration files, libraries, ... have been used during the original execution, there is no need to package the application multiple times with different input parameters.

    @p You can now upload this archive in you OpenMOLE workspace as long with a few @i{data.csv} file in a subfolder named data. Let's now explore a complete combination of all the data files with OpenMOLE. The input data files are located in @i{data} and the result files are written in a folder called @i{results} A second input parameter is a numeric value @i{i} ranging from 1 to 10. The corresponding OpenMOLE script looks like this:
    @p @hl.openmole("""
    // Declare the variable
    val i = Val[Double]
    val input = Val[File]
    val inputName = Val[String]
    val output = Val[File]

    // R task
    // "path/on/your/system" is a path on the original system on which you packaged R
    val rTask = CARETask(workDirectory / "r.tgz.bin", "R --slave -f script.R --args ${i}") set (
      (inputs, outputs) += (i, inputName),
      inputFiles += (input, "data.csv"),
      outputFiles += ("result.csv", output)
    )

    val exploration =
      ExplorationTask(
        (i in (1.0 to 10.0 by 1.0)) x
        (input in (workDirectory / "data").files withName inputName)
      )

    val copy = CopyFileHook(output, workDirectory / "result" / "{inputName}-${i}.csv")
    exploration -< (rTask hook copy hook ToStringHook())""")

  @p The @hl.openmole("CARETask") performs two action: it first unarchives the CARE container by running @hl.highlight("r.tgz.bin", "plain"). Then the actual execution takes place as a second command. Note that for each execution of the @i("CARETask"), All commands starting with @i("/") relate the root of the CARE archive and all other commands are executed in the current directory that is the packaging directory by default.

  @p Several notions from OpenMOLE are reused in this example. If you're not too familiar with
  @a("Hooks", href := DocumentationPages.root.language.hook.file) or
  @a("Samplings", href := DocumentationPages.root.language.sampling.file), check the relevant sections of the
  documentation.

  @sect{Another example with a Python script}

    @p The toy Python script for this test case is:
    @br @hl.highlight("""
    import sys with open(sys.argv[2], 'w') as f:
    f.write(sys.argv[1])
    exit(0)""", "python")

    @p This script is saved to @i{hello.py}. We first package it using CARE:
    @hl.highlight("""care -o hello.tgz.bin python hello.py 42 test.txt""", "plain")

    @p The trailing @b{'/'} character is extremely important in this case as it indicates CARE to use the plain folder format for the archive. With the plain folder archiving format, you can browse and modify the resulting folder @i{hello_archive} as any other folder on your system.

    @p We can now run it in OpenMOLE using the following script:
    @br @hl.openmole("""
    // Declare the variable
    val arg = Val[Int]
    val output = Val[File]

    // python task
    val pythonTask =
      CARETask("hello.tgz.bin", "python hello.py ${arg} output.txt") set (
        inputs += arg,
        outputFiles += ("output.txt", output),
        outputs += arg
      )

    val exploration = ExplorationTask(arg in (0 to 10))

    val copy = CopyFileHook(output, workDirectory / "hello${arg}.txt")
    val env = LocalEnvironment(4)
    exploration -< (pythonTask hook copy on env by 2)""")

   @p Again notions from OpenMOLE are reused in this example. If you're not too familiar with @a("Environments", href := DocumentationPages.root.language.environment.file) or @i{Groupings}, check the relevant sections of the documentation.

  @sect{Advanced options}

    @p The @i{CARETask} can be customised to fit the needs of a specific application. For instance, some applications disregarding standards might not return the expected 0 value upon completion. The return value of the application is used by OpenMOLE to determine whether the task has been successfully executed, or needs to be re-executed. Setting the boolean flag @hl.openmoleNoTest("errorOnReturnValue") to @i{false} will prevent OpenMOLE from re-scheduling a @i{CARETask} that have reported a return code different from 0. You can also get the return code in variable using the @hl.openmoleNoTest("returnValue") setting.

    @p Another default behaviour is to print the standard and error outputs of each task in the OpenMOLE console. Such raw prints might not be suitable when a very large number of tasks is involved or that further processing are to be performed on the outputs. A @i{CARETask}'s standard and error outputs can be assigned to OpenMOLE variable and thus injected in the dataflow by summoning respectively the @hl.openmoleNoTest("stdOut") and @hl.openmoleNoTest("stdErr") actions on the task.

    @p The following snippets creates a task that employs the features described in this section:
    @br @hl.openmole("""
    // Declare the variable
    val output = Val[String]
    val error  = Val[String]
    val value = Val[Int]

    // Any task
    val pythonTask =
      CARETask("hello.tgz.bin", "python hello.py") set (
        stdOut := output,
        stdErr := error,
        returnValue := value
      )""")

    @p You will note that these options are set using the @hl.openmoleNoTest(":=") operator. Also, the OpenMOLE variables containing the standard and error outputs are automatically marked as outputs of the tasks.

  @sect{Using local resources}
    @p To access data present on the execution node (outside the CARE filesystem) you should use a dedicated option of the @i{CARETask}: @i{hostFiles}. This option takes the path of a file on the execution host and bind it at the same path in the CARE filesystem. Optionally you can provide a second argument to specify explicitly the path, for instance:
    @br @hl.openmole("""
      val careTask = CARETask("care.tgz.bin", "executable arg1 arg2 /path/to/my/file /virtual/path arg4") set (
        hostFiles += ("/path/to/my/file"),
        hostFiles += ("/path/to/another/file", "/virtual/path")
      )""")

    @p With in this CAREÂ task you will be able to access @i{/path/to/my/file} and @i{/virtual/path}.

  @sect{Using a local executable (in non portable tasks)}
    @p The CAREÂ task as been designed to be portable from one machine to another. In some case you want to execute specific commands that you know are installed on a given cluster that you know will be available on the execution node. To achieve that you should use another task called @i{SystemExecTask}. This task does'nt embed a CARE archive and is made to launch native command on the execution host.

    @p For instance imagine you want to execute a bash script on the remote host and gather the standard and the error output (note that the bash script will depend on program installed on the remote host, therefore you're task could'nt be considered as portable). To achieve that you should use a @i{SystemExecTask}:
     @br @hl.openmole("""
      // Declare the variable
      val output = Val[String]
      val error  = Val[String]

      // Any task
      val scriptTask =
        SystemExecTask("bash script.sh", "ls") set (
          resources += workDirectory / "script.sh",
          stdOut := output,
          stdErr := error
        )

       scriptTask hook ToStringHook()""")

    @p Note that each execution is isolated in separate folder on the execution host and that the task execution is considered as failed if the script return a value different from 0. If you need another behaviour you can use the same advanced option as the @i{CARETask} regarding the return code.

  @sect{Troubleshooting}
    @p You should always try to re-execute your application outside of OpenMOLE first. This allows you to ensure the packaging process with CARE was successful. If something goes wrong at this stage, you should check the official @a("CARE documentation", href := "http://reproducible.io/") or the archives of the @a("CARE mailing list", href := "https://groups.google.com/forum/?fromgroups#!forum/reproducible").
    @p If the packaged application re-executes as you'd expect, but you still struggle to embed it in OpenMOLE, then get in touch with our user community via our the @a("OpenMOLE user mailing-list", href := "http://list.openmole.org/").
