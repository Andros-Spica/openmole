
@import org.openmole.site.tools._
@import org.openmole.site._

@sect{Embedding a Python script}

    @p The toy Python script for this test case is:
    @br @hl.highlight("""
    import sys
    f = open(sys.argv[2], 'w')
    f.write(sys.argv[1])
    exit(0)""", "python")

    @p This script is saved to @i{hello.py}. We first package it using CARE:
    @hl.highlight("""care -o hello.tgz.bin python hello.py 42 test.txt""", "plain")

    @p We can now run it in OpenMOLE using the following script:
    @br @hl.openmole("""
    // Declare the variable
    val arg = Val[Int]
    val output = Val[File]

    // python task
    val pythonTask =
      CARETask(workDirectory / "hello.tgz.bin", "python hello.py ${arg} output.txt") set (
        inputs += arg,
        outputFiles += ("output.txt", output),
        outputs += arg
      )

    val exploration = ExplorationTask(arg in (0 to 10))

    val copy = CopyFileHook(output, workDirectory / "hello${arg}.txt")
    val env = LocalEnvironment(4)
    exploration -< (pythonTask hook copy on env by 2)""")

    @p Notions from OpenMOLE are reused in this example. If you're not too familiar with @a("Environments", href := DocumentationPages.environment.file) or @i{Groupings}, check the relevant sections of the documentation.

    @p Two things should be noted from this example:
     @ul
       @li{The procedure to package an application @b{is always the same} regardless of the underlying programming language / framework used.}
       @li{The CARETask is not different from the @a("SystemExecTask", href := DocumentationPages.native.file + "#Usingalocalexecutable(innonportabletasks)") TODO refaire le lien pointer vers native packaging, to the extent of the archive given as a first parameter.}
    These two aspects make it really easy to embed native applications in OpenMOLE.


