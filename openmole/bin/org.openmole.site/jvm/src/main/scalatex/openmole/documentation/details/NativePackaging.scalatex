@import org.openmole.site.tools._
@import org.openmole.site._
@import org.openmole.site.NativeDocPageCommons._

@SideMenu.nativePackagingMenu.toBlock.left(320)



  @h1{Native Code Packaging}

@sect{@shared.nativePackagingMenu.introCARE}
      @preamble
      @installCARE

      @paragraphEmbed
      @firstStep
      @listOptionsCARE

      @secondStep
      @importantAspectCARE



The utility of the CARE tool for reproducible science has been covered in the following paper :
@br
    Jonathan Passerat-Palmbach, Romain Reuillon, Mathieu Leclaire, Antonios Makropoulos, Emma C. Robinson, Sarah
    Parisot and Daniel Rueckert,? Reproducible Large-Scale Neuroimaging Studies with the OpenMOLE Workflow
    Management System?, published in @i{Frontiers in Neuroinformatics}, Vol 11, 2017.
    @br
    @a("[online version]" , href:="http://journal.frontiersin.org/article/10.3389/fninf.2017.00021/full#")
    @a("[bibteX]", href:= Resource.bibtex.frontierBib.file)


@sect{@shared.nativePackagingMenu.advancedOptions}

    @p The @i{CARETask} can be customised to fit the needs of a specific application. For instance, some applications disregarding standards might not return the expected 0 value upon completion. The return value of the application is used by OpenMOLE to determine whether the task has been successfully executed, or needs to be re-executed. Setting the boolean flag @hl.openmoleNoTest("errorOnReturnValue") to @i{false} will prevent OpenMOLE from re-scheduling a @i{CARETask} that have reported a return code different from 0. You can also get the return code in a variable using the @hl.openmoleNoTest("returnValue") setting.

    @p Another default behaviour is to print the standard and error outputs of each task in the OpenMOLE console. Such raw prints might not be suitable when a very large number of tasks is involved or that further processing are to be performed on the outputs. A @i{CARETask}'s standard and error outputs can be assigned to OpenMOLE variable and thus injected in the dataflow by summoning respectively the @hl.openmoleNoTest("stdOut") and @hl.openmoleNoTest("stdErr") actions on the task.

    @p As any other process, the applications contained in OpenMOLE's native tasks accept environment variables to influence their behaviour.
    Variables from the dataflow can be injected as environment variables using the @hl.openmoleNoTest{environmentVariable += (variable, "variableName")} field.
    If no name is specified, the environment variable is named after the OpenMOLE variable.
    Environment variables injected from the dataflow are @b{inserted in the pre-existing set of environment variables from the execution host}. This shows particularly useful to preserve
    the behaviour of some toolkits when executed on local environments (ssh, clusters, ...) where users control their work environment.

    @p The following snippet creates a task that employs the features described in this section:
    @br @hl.openmole("""
    // Declare the variable
    val output = Val[String]
    val error  = Val[String]
    val value = Val[Int]

    // Any task
    val pythonTask =
      CARETask("hello.tgz.bin", "python hello.py") set (
        stdOut := output,
        stdErr := error,
        returnValue := value,
        environmentVariable += (value, "I_AM_AN_ENV_VAR")
      )""")

    @p You will note that @b{options holding a single value} are set using the @hl.openmoleNoTest(":=") operator. Also, the OpenMOLE variables containing the standard and error outputs are @b{automatically marked as outputs} of the task, and must not be added to the @hl.openmoleNoTest("outputs") list.

@sect{@shared.nativePackagingMenu.localResources}
    @p To access data present on the execution node (outside the CARE filesystem) you should use a dedicated option of the @i{CARETask}: @i{hostFiles}. This option takes the path of a file on the execution host and binds it to the same path in the CARE filesystem. Optionally you can provide a second argument to specify the path explicitly. For instance:
    @br @hl.openmole("""
      val careTask = CARETask("care.tgz.bin", "executable arg1 arg2 /path/to/my/file /virtual/path arg4") set (
        hostFiles += ("/path/to/my/file"),
        hostFiles += ("/path/to/another/file", "/virtual/path")
      )""")

    @p This CARE?task will thus be able to access @i{/path/to/my/file} and @i{/virtual/path}.


@sect{@shared.nativePackagingMenu.localExecutable}
    @p The @i{CARETask} was designed to be portable from one machine to another. However, some use-cases require executing specific commands installed on a given cluster. To achieve that you should use another task called @i{SystemExecTask}. This task is made to launch native commands on the execution host. There is two modes for using this task:
    @ul
      @li{Calling a command that is @b{assumed to be available on any execution node of the environment}. The command will be looked for in the system as it would from a traditional command line: searching in the default @i{PATH} or an absolute location.}
      @li{Copying a @b{local script not installed on the remote environment}. Applications and scripts can be copied to the task's work directory using the @hl.openmoleNoTest("resources") field. Please note that contrary to the CARETask, there is @b{no guarantee that an application passed as a resource to a SystemExecTask will re-execute successfully on a remote environment}}.

    @p The @i{SystemExecTask} accepts an arbitrary number of commands. These commands will be @b{executed sequentially on the same execution node} where the task is instantiated. In other words, it is not possible to split the execution of multiple commands grouped in the same @i{SystemExecTask}.

    @p The following example first copies and runs a bash script on the remote host, before calling the remote's host @hl.highlight("/bin/hostname", "plain"). Both commands' standard and error outputs are gathered and concatenated to a single OpenMOLE variable: respectively @hl.openmoleNoTest("stdOut") and @hl.openmoleNoTest("stdErr").  To achieve that you should use a @i{SystemExecTask}:
     @br @hl.openmole("""
      // Declare the variable
      val output = Val[String]
      val error  = Val[String]

      // Any task
      val scriptTask =
        SystemExecTask("bash script.sh", "hostname") set (
          resources += workDirectory / "script.sh",
          stdOut := output,
          stdErr := error
        )

       scriptTask hook ToStringHook()""")

    @p In this case the bash script might depend on program installed on the remote host. Similarly, we @b{assume the presence} of @hl.highlight("/bin/hostname", "plain") on the execution node. Therefore this task cannot be considered as portable.

    @p Note that each execution is isolated in separate folder on the execution host and that the task execution is considered as failed if the script return a value different from 0. If you need another behaviour you can use the same advanced options as the @i{CARETask} regarding the return code.