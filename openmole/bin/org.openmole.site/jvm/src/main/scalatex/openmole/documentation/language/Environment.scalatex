@import org.openmole.site.tools._
@import org.openmole.site._
@import org.openmole.site.Environment._

@p
A key feature in OpenMOLE is the possibility to delegate the workload to a remote execution environment. Tasks in OpenMOLE have been designed so that the delegation a part of the workload to a remote environment is declarative.

@sect{Setting up an Authentication}
  You first need to define an authentication method for the environment(s) you want to use.
  The way to achieve this is describe in the @aa("GUI guide", href := DocumentationPages.gui.anchor(shared.guiGuide.authentication))
  Have a look @aa("here", href := DocumentationPages.console.anchor(shared.consoleMenu.authentication)) to set up authentication in console mode.

@sect{Defining an execution Environment}
  The actual delegation of the task is noted by the keyword @hl.openmoleNoTest("on") followed by a defined @i{Environment}:
  @br @hl.openmole("""
  val env = LocalEnvironment(10)

  val t1 = EmptyTask()
  val t2 = EmptyTask()
  val t3 = EmptyTask()

  val mole = t1 -- (t2 on env) -- t3""")

  @p You do not need to install anything or perform any kind of configuration on the target execution environment for
  OpenMOLE to work. It reuses the infrastructure in place. You will however be required to provide the authentication
  information in order for OpenMOLE to access the remote environment. At this point, just specify the credentials you're
  using to login to this environment outside of OpenMOLE. Voila! That's all you need to do to use your environment
  through OpenMOLE. In case you face authentication problems when targeting an environment through SSH, please refer
  to the corresponding entry in the @a("FAQ", href := Pages.faq.file).

  @p When no specific environment is specified for a task, or a group of tasks, they will be executed sequentially on your
  local machine.

@sect{Grouping}
  @p The use of a batch environment is generally not suited for short tasks (less than a 1 minute for a cluster, or less
  than 1 hour for a grid). In case your tasks are short you can group several executions. To group the execution by 100
  in each job submitted to the environment, use the keyword @hl.openmoleNoTest("by"):
  @br @hl.openmole("""
  val mole = explo -< (t1 on env by 100)
  """, header = """
  val env = LocalEnvironment(10)
  val t1 = EmptyTask()
  val i = Val[Int]
  val explo = ExplorationTask(i in (0 to 10000))
  """)

@sect{Available environments}
  @p Multiple environments are available to delegate your workload, depending the kind of resources you have on disposal.
  @p The @a("Multi-thread", href := DocumentationPages.multithread.file) permits to execute the tasks concurrently on your machine,
   the @a("SSH", href := DocumentationPages.ssh.file) one to execute tasks on remote server through SSH.
   You can also access a wide variety of @aa("clusters", href := DocumentationPages.cluster.file) like
   @aa("PBS/Torque", href := DocumentationPages.cluster.anchor(shared.clusterMenu.pbsTorque)),
   @aa("SGE", href := DocumentationPages.cluster.anchor(shared.clusterMenu.sge)),
   @aa("Slurm", href := DocumentationPages.cluster.anchor(shared.clusterMenu.slurm)),
   @aa("Condor", href := DocumentationPages.cluster.anchor(shared.clusterMenu.condor)),
   or @aa("OAR", href := DocumentationPages.cluster.anchor(shared.clusterMenu.oar)).
   You can also use @aa("EGI", href := DocumentationPages.egi.file) to execute tasks on the @a("EGI grid", href := "http://www.egi.eu/"),
   or the @aa("Ad-hoc Desktop Grid", href := DocumentationPages.desktopGrid.file) to distribute your workflows on a set of desktop/laptop computers.

