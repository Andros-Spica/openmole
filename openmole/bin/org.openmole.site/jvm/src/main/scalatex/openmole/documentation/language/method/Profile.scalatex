@import org.openmole.site.tools._
@import org.openmole.site._
@import org.openmole.site.stylesheet._


@def modelAndVariables = """
val param1 = Val[Double]
val param2 = Val[Double]
val output1 = Val[Double]
val output2 = Val[Double]
val modelTask = EmptyTask() set (
    inputs += (param1,param2),
    outputs += (output1, output2)
    )
val myseed = Val[Int]
val x = Val[Double]
val fitness = Val[Double]"""



The profile method is designed to test the sensitivity of the input parameters in a calibration context.
Although it may look similar to traditional sensitivity analysis in principle, the calibration profile
algorithm goes deeper, as it captures the full effect of a parameter variation on the model fitness, every other input
 being calibrated to optimize the fitness.
 @br
 Profiles reveal a lot about your model, as they may show how an input (i.e. a parameter of the model) has so much effect on the model
 dynamics that it has to be in a certain interval for the model to produce acceptable dynamics! In other cases, on the
 contrary, Calibration Profiles show that an input can so much be compensated by other inputs that it will not have enough
  effect to constrain the model towards acceptable dynamics by itself.

@break
@Resource.rawFrag(Resource.img.method.profileID)


@br
@b{Method scores:}
@br
The calibration profile method is perfect to reveal a model's sentitivity regarding its parameter, hence the highest score possible in sensitivity.
However, it does not retrieve information about the input space nor the output space structures, as it focus on @b{one} parameter/input, every other input being let free.
As the studied parameter varies, the other parameter are calibrated (see below), so this method scores very well
regarding calibration, which is also why it can handle stochasticity since calibration does too.
Finally, the profile method realizes calibrations on the other inputs for each interval of the input under study, so the more inputs, the more
sensitive to dimensionality of input space.

@Resource.rawFrag(Resource.img.method.profileAnim)
@br
@basicButton("Run", classIs(btn ++ btn_danger))(id := shared.profile.button, stylesheet.svgRunButton(-70))

@p
    Given a distance measure between the model output values and
    data, the profile of a selected parameter @b{i} is constructed by
    dividing the interval within which  @b{i} can vary into subintervals
    of equal size, and calibrating the model within each interval to
    minimise the distance (similarly to @a("Calibration", href :=
    DocumentationPages.calibration.file)) between outputs and data.  The
    optimisation is made over the other parameters of the model which are
    left free.

@p
As an example, let's consider a model with 3 parameters i, j and k,
each taking real values between 1 and 10. The profile of the parameter
  i is made by splitting the [1,10] interval into (for example) 9
intervals of size 1. Calibration is performed in parallel within each
  interval. At the end of the minimisation, we obtain sets of parameter
values minimising the given distance with i taking values in each
subinterval. By plotting the distance against the values of i, one
can visually determine what values i must take for the model to be
  able to reproduce the data.

@p
By defining a threshold below which the distance between the model output and the data
is considered acceptable, the results of the profile methods can be interpreted as
  the subset of values of the parameter for which the model output reproduces the data
sufficiently well.

@p
The Profile method takes the following parameters:
  @ul
  @li{@hl.code("inputs"): a list of the model parameters with their minimum and maximum bounds,}
  @li{@hl.code("objective"): a variable defined in the OpenMOLE script that contains the distance between the data and the model output,}
  @li{@hl.code("x"): the parameter which is being profiled,}
  @li{@hl.code("nX"): the size of the subintervals.}
  @li{@hl.code("stochastic"): the seed provider, mandatory if your model contains randomness}
@p
You will also need an evolutionary scheme and can use SteadyStateEvolution as described in @a("Calibration", href :=
  DocumentationPages.calibration.file))

@p To profile a parameter, use the GenomeProfile constructor like so:
  @br @hl.openmole("""
  val exploration =
    GenomeProfile(
      x = param1,
      nX = 20,
      genome =
        Seq(
          param1 in (0.0, 99.0),
          param2 in (0.0, 99.0)),
      objective = fitness,
      stochastic = Stochastic(seed = myseed))

val evolution =
  SteadyStateEvolution(
    algorithm = exploration,
    evaluation = modelTask,
    parallelism = 10,
    termination = 100
  )
""", header= modelAndVariables , name = "Profile")
where @hl.code("param1") and @hl.code("param2") are inputs
of the task that runs the model (and refer to the model parameters),
and @hl.code("fitness") is an output of that
  same task. The number of inputs are illimited. Here, @hl.code("x = 0")
specifies that we are profiling @hl.code("param1").



@break
@todo
  Guillaume/romain ? Il manque l'explication et l'usage dans un contexte expérimental: , dire quelle question ça permet de poser , les profils types et interprétations associées, Dire que chaque point est une calibration, etc.

@break

The calibration profile algorithm has been published in the following paper:

Romain Reuillon, Clara Schmitt, Ricardo De Aldama, and Jean-Baptiste Mouret, «A New Method to Evaluate Simulation
       Models: The Calibration Profile (CP) Algorithm » published in @i{Journal of Artificial Societies and Social Simulation}
        (JASSS) , Vol 18, Issue 1, 2015.
        @br
            @a("[online version]" , href:="http://jasss.soc.surrey.ac.uk/18/1/12.html")  @a("[bibteX]", href:= Resource.bibtex.profilemethodBib.file)
