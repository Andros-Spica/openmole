@import org.openmole.site.stylesheet._
@import org.openmole.site._
@import org.openmole.site.tools._
@import DocumentationPages._



@h2{Grid sampling}

A grid sampling (also called complete sampling) consists in evaluating every possible combination of the provided input values, for a reasonable number of dimensions and discretisation steps.


@h3{Method's score}

@Resource.rawFrag(Resource.img.method.completeID)

@br

Grid sampling is a good way of getting a first glimpse at the output space of your model when you don't know anything about your input space structure.
However, it will not give you any information ont the structure of the output space, as there is no reason for evenly spaced inputs to lead to evenly spaced outputs.

@br

Grid sampling is hampered by input space dimensionality, as high dimension spaces need a lot of samples to be covered, as well as a lot of memory to store them.

@br@br

A grid sampling is declared via the @code{DirectSampling} task, in which the bounds and discretisation steps of each input to vary  are declared:

@br@br

@hl.openmole("""
   val input_i = Val[Int]
   val input_j = Val[Double]

   DirectSampling(
     evaluation = my_own_evaluation  ,
     sampling =
       (input_i in (0 to 10 by 2)) x
       (input_j in (0.0 to 5.0 by 0.5)),
     aggregation= my_aggregation
   )""", name = "syntax of DirectSampling Task")

@br

with
@ul
  @li{@code{evaluation} is the task (or composition of tasks) that uses your inputs, typically your model task and a hook,}
  @li{@code{sampling} is the sampling task,}
  @li{@code{aggregation} (@i{optional}) is an aggregation task to be performed on the outputs of your evaluation task.}

Here is a dummy workflow showing the exploration of a Java model, that takes an integer value as input, and generates a string as output:

@br@br

@hl.openmole("""
// Inputs and outputs declaration
val i = Val[Int]
val o = Val[Double]
val avg = Val[Double]

// Defines the model
val myModel =
  ScalaTask("val o = i * 2") set (
    inputs += i,
    outputs += (i, o)
  )

val average =
  ScalaTask("val avg = o.average") set (
    inputs += o.toArray,
    outputs += avg
  )

DirectSampling(
  evaluation = myModel hook DisplayHook(),
  sampling = i in (0 to 10 by 1),
  aggregation = average hook DisplayHook()
)""", name="concrete example of direct sampling")

Some details:
@ul
 @li{@code{myModel} is the task that multiply the input by 2,}
 @li{the @code{evaluation} attribute of the @code{DirectSampling} task is the composition of myModel and a hook,}
 @li{the @code{aggregation} attribute of the @code{DirectSampling} task is the @code{average} task, a ScalaTask that computes the average of an array Double values,}
 @li{the task declared under the name @code{exploration} is a DirectSampling task, which means it will generate parallel executions of @code{myModel}, one for each sample generated by the sampling task.}



@h2{One factor at a time sampling}

In the case of models requiring a long time to run, or for preliminary experiments, one may want to proceed to a sampling similar to the grid sampling, with a reduced number of total runs.
For this, one can vary each factor successively in its domain, the others being fixed to a nominal value.

The sampling primitive @code{OneFactorSampling} does so and takes as arguments any number of factors decorated by the keyword @code{nominal} and the nominal value.

It is used as follows in an example with a @code{DirectSampling}:

@br@br

@hl.openmole("""
val x1 = Val[Double]
val x2 = Val[Double]
val o = Val[Double]

val myModel = ScalaTask("val o = x1 + x2") set (
    inputs += (x1,x2),
    outputs += (x1,x2, o)
  )

val exploration = DirectSampling(
    evaluation = myModel hook DisplayHook(),
    sampling = OneFactorSampling(
      (x1 in (0.0 to 1.0 by 0.2)) nominal 0.5,
      (x2 in (0.0 to 1.0 by 0.2)) nominal 0.5
    )
  )

exploration""", name="example of one factor at a time")