
@import org.openmole.site.tools._
@import org.openmole.site._
@import org.openmole.site.stylesheet._
@import DocumentationPages._

@def model = """
val param1 = Val[Double]
val param2 = Val[Double]
val output1 = Val[Double]
val output2 = Val[Double]
    val modelTask = EmptyTask() set (
    inputs += (param1,param2),
    outputs += (output1, output2)
    ) """



@h2{PSE description}

The Pattern Space Exploration (PSE) method is used to @b{explore the output's diversity of a model}.
Input parameter values are selected to produce new output values, such that as the exploration progresses, the region of the output space that is covered gets bigger.
PSE reveals the potential of your model: the variety of dynamics it is able to produce, even those you were not investigating in the first place!


@h3{Method's score}

@Resource.rawFrag(Resource.img.method.pseID)

@br

The PSE method is designed to cover the output space, hence it gets the highest possible score in output exploration.
Since PSE is all about @i{covering} output space, it gets low scores in optimization and input space exploration.
As the method discovers new patterns in the output space, you can get some insight about the sensitivity of the model by looking at the input values leading to these patterns.
Contrarily to calibration-based methods, PSE is sensitive to the dimensionality of the output space, as it records all the locations that were covered during the exploration.
This can quickly become costly for more than three or four dimensions.

@br

PSE handles stochasticity in the sense that the selected patterns are estimated by the median of several model execution output values.


@h3{How it works}

The PSE method searches for diverse output values.
As with all evolutionary algorithms, PSE generates new individuals through a combination of genetic inheritance from the parent individuals and mutation.
PSE (inspired by @a("novelty search", href := shared.link.noveltySearch)) selects for the parents whose output values are rare compared to the rest of the population and to the previous generations.
In order to evaluate the rarity of an output value, PSE discretises the output space, dividing it into cells.
Each time a simulation is run and its output is known, a counter is incremented in the corresponding cell.
PSE preferentially selects the parents whose associated cells have low counters.
By selecting parents with rare output values, we try and increase the chances to produce new individuals with previously unobserved behaviours.

@Resource.rawFrag(Resource.img.method.pseAnim)
@br
@basicButton("Run", classIs(btn ++ btn_danger))(id := shared.pse.button, stylesheet.svgRunButton(-50))


@h3{Typed signature}

The PSE method can be typed as:

@br@br

@div(style:="text-align:center")
    PSE :   (X ‚Üí Y) ‚Üí ùìü(X)
    @br
    such that : PSE(M) = M(X)

@br

With M, the model ; X, the input space ; Y, the output space ; and ùìü(X) the power set of X (@i{i.e.} every subset of X, including X and ‚àÖ).

@br

In other words, this function takes a model M whose signature is (X‚ÜíY), an element @i{y} of Y representing the list of criterion values to reach, and finds a list @i{x} of elements of X such that M(@i{x}) are Pareto dominant compared to every image of other elements of X by M, regarding criterion @i{y}.



@h2{PSE within OpenMOLE}

The OpenMOLE task for PSE is @code{PSEEvolution}.
It takes the following parameters:
@ul
  @li{@code{evaluation} the OpenMOLE task that runs the simulation, @i{i.e.} the model,}
  @li{@code{parallelism} the number of simulations that will be run in parallel,}
  @li{@code{termination} the total number of evaluations to be executed,}
  @li{@code{genome} a list of the model parameters and their respective variation intervals,}
  @li{@code{objectives} a list of indicators measured for each evaluation of the model within which we search for diversity, with a discretization step,}
  @li{@code{stochastic} the seed generator, which generates suitable seeds for the method. Mandatory if your model contains randomness. The generated seed for the model task is transmitted through the variable given as an argument of @code{Stochastic} (here myseed).}

Here is a use example of the PSE method in an OpenMOLE script:

@br@br

@hl.openmole("""
// Seed declaration for random number generation
val myseed =Val[Int]

// PSE method
PSEEvolution(
  evaluation = modelTask,
  parallelism = 10,
  termination = 100,
  genome = Seq(
    param1  in (0.0, 1.0),
    param2 in (-10.0, 10.0)),
  objectives = Seq(
    output1 in (0.0 to 40.0 by 5.0),
    output2 in (0.0 to 4000.0 by 50.0)),
  stochastic = Stochastic(seed = myseed)
) hook (workDirectory / "results", frequency = 100)
""",header=model, name = "PSE")

@br

Where @code{param1} and @code{param2} are inputs of the task running the model, and @code{output1} and @code{output2} are outputs of that same task.
The number of inputs and outputs are unlimited.

@br@br

Note that this method is subject to the curse of dimensionality on the output space, meaning that the number of output patterns can grow as a power of the number of output
variables.
With more than just a few output variables, the search space may become so big that the search will take too long to complete and the search results will take more memory than a modern computer can handle.
Restricting the number of output variables to 2 or 3 also facilitates the interpretation of the results, making them easy to visualise.

@br@br

The PSE method is described in the following scientific paper :
@br
Guillaume Ch√©rel, Cl√©mentine Cottineau and Romain Reuillon, ¬´ Beyond Corroboration: Strengthening Model Validation by Looking for Unexpected Patterns¬ª published in @i{PLOS ONE} 10(9), 2015.
@br
@a("[online version]" , href:=shared.link.paper.beyondCorroboration) @a("[bibteX]", href:= Resource.bibtex.PSEmethodBib.file)


@h3{Stochastic models}

You can check additional options to run PSE on stochastic models on @aa("this page", href := stochasticityManagement.file).