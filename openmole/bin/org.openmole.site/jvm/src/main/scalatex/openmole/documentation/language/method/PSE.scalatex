
@import org.openmole.site.tools._
@import org.openmole.site._

@p{PSE Method}

@figure
  @img(src := Resource.img.vignette_pse.file, width:= "90%")
    @figcaption
      Figure: Input parameter values are selected to produce new output
      values, such that as the exploration progresses, the region of
      the output space that is covered gets bigger.


@p
    The PSE method searches for diverse output values. As with all
    evolutionary algorithms, PSE generates new individuals through
    a combination of genetic inheritance from parent individuals
    and mutation. PSE (inspired by @a("novelty search", href := "http://eplex.cs.ucf.edu/noveltysearch/userspage/")) selects for
    the parents whose output values are rare compared to the rest of
    the population and to the previous generations. In order to evaluate
    the rarity of a the output values, PSE discretises the output space,
    dividing it into cells. Each time a simulation is run and its output
    is known, a counter is incremented in the corresponding cell. PSE
    preferentially selects the parents whose associated cells have
    low counters. By selecting parents with rare output values, we try and increase the
    chances to produce new individuals with previously unobserved
    behaviours.


@p
    PSE takes the following parameters:
@ul
    @li{@hl.code("inputs"): the model parameters with their minimum and maximum bounds,}
    @li{@hl.code("observables"): the observables measured for each simulation and within which we search for diversity,}
    @li{@hl.code("gridSize"): the discretisation step for each observable.}

@p
  You will also need an evolutionary scheme and can use SteadyStateEvolution as described in @a("Calibration", href :=
  DocumentationPages.root.language.method.calibration.file))

@p To use PSE as the exploration method in openmole, use the PSE constructor like so:
@br @hl.openmole("""
val exploration =
    PSE (
      inputs =
        Seq(
          param1 -> (0.0, 1.0),
          param2 -> (-10.0, 10.0)),
      observables =
        Seq(
          output1,
          output2),
      gridSize = Seq(40.0, 10.0),
    )

val evolution =
    SteadyStateEvolution(
      algorithm = exploration,
      evaluation = modelTask,
      parallelism = 10,
      termination = 100 
    )""", name = "PSE")
where @hl.code("param1") and @hl.code("param2") are inputs
of the task that runs the model, and @hl.code("output1") and
@hl.code("output2") are outputs of that same task. The number
of inputs and outputs are illimited.
@p
    Note that the method is subject
    to the curse of dimensionality on the output space, meaning that the
    number of output patterns can grow as a power of the number of output
    variables. With more than just a few output variables, the search space
    may become so big that the search will take too long to complete and the
    search results will take more memory than one can handle on a modern
    computer. Restricting the number of output variables to 2 or 3 also
    facilitates the interpretation of the results, making them easy to visualise.
